<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="histo-header_8h" kind="file">
    <compoundname>histo-header.h</compoundname>
    <includes local="no">vector</includes>
    <includes local="no">algorithm</includes>
    <includes local="no">utility</includes>
    <includes local="no">stdexcept</includes>
    <includes local="no">cmath</includes>
    <includes local="no">iostream</includes>
    <incdepgraph>
      <node id="5">
        <label>cmath</label>
      </node>
      <node id="4">
        <label>stdexcept</label>
      </node>
      <node id="1">
        <label>vector</label>
      </node>
      <node id="3">
        <label>utility</label>
      </node>
      <node id="6">
        <label>iostream</label>
      </node>
      <node id="2">
        <label>algorithm</label>
      </node>
      <node id="0">
        <label>/home/phc/repository_local/histo-header/src/histo-header.h</label>
        <link refid="histo-header.h"/>
        <childnode refid="1" relation="include">
        </childnode>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
    </incdepgraph>
    <innerclass refid="classhisto_1_1histo__error" prot="public">histo::histo_error</innerclass>
    <innerclass refid="structhisto_1_1_histo" prot="public">histo::Histo</innerclass>
    <innernamespace refid="namespacehisto">histo</innernamespace>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Histogram in C++11, 1D, simple header-only, inspired by R, calculate and optimize breaks automatically. Accepts different precissions. Copyright (C) 2015 Pablo Hernandez. github/phcerdan/histo-header.</para><para>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.</para><para>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</para><para>You should have received a copy of the GNU Lesser General Public License along with this library; if not, see &lt;<ulink url="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</ulink>&gt;. </para>    </detaileddescription>
    <programlisting>
<codeline lineno="1"></codeline>
<codeline lineno="20"><highlight class="preprocessor">#ifndef<sp/>HISTO_HEADER_H_</highlight></codeline>
<codeline lineno="21"><highlight class="preprocessor"></highlight><highlight class="preprocessor">#define<sp/>HISTO_HEADER_H_</highlight></codeline>
<codeline lineno="22"><highlight class="preprocessor"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdexcept&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cmath&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight></codeline>
<codeline lineno="29" refid="namespacehisto" refkind="compound"><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">histo<sp/>{</highlight></codeline>
<codeline lineno="35" refid="group__breaks__methods_1ga132dcd8240c4bb268ed00b1e4fa3ebab" refkind="member"><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__breaks__methods_1ga132dcd8240c4bb268ed00b1e4fa3ebab" kindref="member" tooltip="Breaks method to optimal calculation of breaks based on input data and range. Scott...">breaks_method</ref><sp/>{</highlight></codeline>
<codeline lineno="37" refid="group__breaks__methods_1gga132dcd8240c4bb268ed00b1e4fa3ebabae05f2a05e4a163aac88bf64dc92cb36e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__breaks__methods_1gga132dcd8240c4bb268ed00b1e4fa3ebabae05f2a05e4a163aac88bf64dc92cb36e" kindref="member">Scott</ref><sp/>=<sp/>0</highlight></codeline>
<codeline lineno="38"><highlight class="normal">};</highlight></codeline>
<codeline lineno="54"><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PRECI<sp/>=<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&gt;</highlight></codeline>
<codeline lineno="55" refid="group___generate_breaks_1ga853c19bd3a41d2c20e32828507ab04eb" refkind="member"><highlight class="normal">std::vector&lt;T&gt;<sp/><ref refid="group___generate_breaks_1ga853c19bd3a41d2c20e32828507ab04eb" kindref="member" tooltip="Help functions to manually creating breaks from input range (low, upper) and desired...">GenerateBreaksFromRangeAndBins</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>low,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>upper,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;bins){</highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;T&gt;<sp/>breaks(bins+1);</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>width<sp/>=<sp/>(upper<sp/>-<sp/>low)/<sp/>static_cast&lt;PRECI&gt;(bins);</highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i!=bins+1;<sp/>i++){</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>breaks[i]<sp/>=<sp/>low<sp/>+<sp/>i*width;</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>breaks;</highlight></codeline>
<codeline lineno="62"><highlight class="normal">};</highlight></codeline>
<codeline lineno="63"><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PRECI<sp/>=<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&gt;</highlight></codeline>
<codeline lineno="66" refid="group___generate_breaks_1gaf937f2bdf0ef388ea4a3aeb6e29effb2" refkind="member"><highlight class="normal">std::vector&lt;T&gt;<sp/><ref refid="group___generate_breaks_1ga853c19bd3a41d2c20e32828507ab04eb" kindref="member" tooltip="Help functions to manually creating breaks from input range (low, upper) and desired...">GenerateBreaksFromRangeAndBins</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::pair&lt;T,T&gt;<sp/>&amp;range_low_upper,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;bins){</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/>T<sp/>low<sp/><sp/><sp/>=<sp/>range_low_upper.first;</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/>T<sp/>upper<sp/>=<sp/>range_low_upper.second;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>GenerateBreaksFromRangeAndBins&lt;T,<sp/>PRECI&gt;(low,<sp/>upper,<sp/>bins);</highlight></codeline>
<codeline lineno="70"><highlight class="normal">};</highlight></codeline>
<codeline lineno="74" refid="classhisto_1_1histo__error" refkind="compound"><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classhisto_1_1histo__error" kindref="compound">histo_error</ref><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>std::runtime_error<sp/>{</highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="77" refid="classhisto_1_1histo__error_1ae4a9c52c6c031ea03210e9e585778827" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classhisto_1_1histo__error_1ae4a9c52c6c031ea03210e9e585778827" kindref="member">histo_error</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>&amp;<sp/>s)<sp/>:<sp/>std::runtime_error(s){<sp/>};</highlight></codeline>
<codeline lineno="78"><highlight class="normal">};</highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Container&gt;</highlight></codeline>
<codeline lineno="90" refid="namespacehisto_1a6fdcb336cae7bfe66ad7963f3ce49c66" refkind="member"><highlight class="normal">T<sp/><ref refid="namespacehisto_1a6fdcb336cae7bfe66ad7963f3ce49c66" kindref="member" tooltip="Variance calculation from Container with data.">variance_welford</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Container&amp;<sp/>xs)</highlight></codeline>
<codeline lineno="91"><highlight class="normal">{</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>M<sp/>=<sp/>0,<sp/>S<sp/>=<sp/>0,<sp/>Mprev<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>x<sp/>:<sp/>xs)<sp/>{</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++N;</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Mprev<sp/>=<sp/>M;</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>M<sp/>+=<sp/>(x<sp/>-<sp/>Mprev)<sp/>/<sp/>N;</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>S<sp/>+=<sp/>(x<sp/>-<sp/>Mprev)<sp/>*<sp/>(x<sp/>-<sp/>M);</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>S<sp/>/<sp/>(N-1);</highlight></codeline>
<codeline lineno="101"><highlight class="normal">}</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="109" refid="namespacehisto_1aa9dc1974bd94dd4af223b30e7c1c33b1" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="namespacehisto_1aa9dc1974bd94dd4af223b30e7c1c33b1" kindref="member">isequalthan</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>v1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>v2)</highlight></codeline>
<codeline lineno="110"><highlight class="normal">{</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::abs(v1-v2)&lt;=<sp/>std::numeric_limits&lt;T&gt;::epsilon();</highlight></codeline>
<codeline lineno="112"><highlight class="normal">}</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PRECI<sp/>=<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PRECI_INTEGER<sp/>=<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;</highlight></codeline>
<codeline lineno="125" refid="structhisto_1_1_histo" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structhisto_1_1_histo" kindref="compound" tooltip="Histogram inspired by R. Simple, no dependancies, header-only. It accepts different...">Histo</ref><sp/>{</highlight></codeline>
<codeline lineno="126"><highlight class="normal"></highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight><highlight class="comment">/*************<sp/>DATA<sp/>*****************/</highlight></codeline>
<codeline lineno="129" refid="structhisto_1_1_histo_1aae8bee662fbf5b3f00e2b5bc8e304036" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>std::pair&lt;T,T&gt;<sp/><ref refid="structhisto_1_1_histo_1aae8bee662fbf5b3f00e2b5bc8e304036" kindref="member">range</ref>;</highlight></codeline>
<codeline lineno="132" refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;T&gt;<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>;</highlight></codeline>
<codeline lineno="134" refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bins{0};</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;PRECI_INTEGER&gt;<sp/><ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>;</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"></highlight><highlight class="comment">/**********<sp/>CONSTRUCTORS<sp/>************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo" kindref="compound" tooltip="Histogram inspired by R. Simple, no dependancies, header-only. It accepts different...">Histo</ref>()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight></codeline>
<codeline lineno="147" refid="structhisto_1_1_histo_1a7065d3edf9a7db33a93930b5bf7ae44d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo" kindref="compound" tooltip="Histogram inspired by R. Simple, no dependancies, header-only. It accepts different...">Histo</ref>(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;data,<sp/><ref refid="group__breaks__methods_1ga132dcd8240c4bb268ed00b1e4fa3ebab" kindref="member" tooltip="Breaks method to optimal calculation of breaks based on input data and range. Scott...">histo::breaks_method</ref><sp/>method<sp/>=<sp/><ref refid="group__breaks__methods_1gga132dcd8240c4bb268ed00b1e4fa3ebabae05f2a05e4a163aac88bf64dc92cb36e" kindref="member">Scott</ref><sp/>)</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>range_ptr<sp/>=<sp/>std::minmax_element(data.begin(),<sp/>data.end());</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1aae8bee662fbf5b3f00e2b5bc8e304036" kindref="member">range</ref><sp/><sp/><sp/><sp/><sp/>=<sp/>std::make_pair(*range_ptr.first,<sp/>*range_ptr.second);</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref><sp/><sp/><sp/><sp/>=<sp/>CalculateBreaks(data,<sp/>range,<sp/>method);</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bins<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">decltype(bins)</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>.size()<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a59b9327bd63469648ca27cd666adab79" kindref="member" tooltip="Resize counts and reset value to zero.">ResetCounts</ref>();</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a24f8c6d3b739d1199674198f49aebd28" kindref="member" tooltip="Fill counts from data. Breaks must have been set-up before calling this method.">FillCounts</ref>(data);</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="156"><highlight class="normal"></highlight></codeline>
<codeline lineno="163" refid="structhisto_1_1_histo_1a7d313fd5714037fe2fde6108b30db86a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a7d313fd5714037fe2fde6108b30db86a" kindref="member" tooltip="Constructor with fixed input range.">Histo</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;data,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::pair&lt;T,T&gt;<sp/>&amp;input_range,<sp/><ref refid="group__breaks__methods_1ga132dcd8240c4bb268ed00b1e4fa3ebab" kindref="member" tooltip="Breaks method to optimal calculation of breaks based on input data and range. Scott...">histo::breaks_method</ref><sp/>method<sp/>=<sp/><ref refid="group__breaks__methods_1gga132dcd8240c4bb268ed00b1e4fa3ebabae05f2a05e4a163aac88bf64dc92cb36e" kindref="member">Scott</ref><sp/>){</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1aae8bee662fbf5b3f00e2b5bc8e304036" kindref="member">range</ref><sp/><sp/><sp/><sp/><sp/>=<sp/>input_range;</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref><sp/><sp/><sp/><sp/>=<sp/>CalculateBreaks(data,<sp/><ref refid="structhisto_1_1_histo_1aae8bee662fbf5b3f00e2b5bc8e304036" kindref="member">range</ref>,<sp/>method);</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bins<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">decltype(bins)</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>.size()<sp/>-<sp/>1<sp/>);</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a59b9327bd63469648ca27cd666adab79" kindref="member" tooltip="Resize counts and reset value to zero.">ResetCounts</ref>();</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>FillCounts(data);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="178" refid="structhisto_1_1_histo_1adb33e8e9c73bde47027926f5c7315545" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1adb33e8e9c73bde47027926f5c7315545" kindref="member" tooltip="Constructor that accepts a vector of breaks. You can use.">Histo</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;data,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;input_breaks)<sp/>{</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref><sp/>=<sp/>input_breaks;</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1aae8bee662fbf5b3f00e2b5bc8e304036" kindref="member">range</ref><sp/><sp/>=<sp/>std::make_pair(<ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>[0],<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>[<ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>.size()<sp/>-<sp/>1]);</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bins<sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">decltype(bins)</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>.size()<sp/>-<sp/>1<sp/>);</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a59b9327bd63469648ca27cd666adab79" kindref="member" tooltip="Resize counts and reset value to zero.">ResetCounts</ref>();</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a24f8c6d3b739d1199674198f49aebd28" kindref="member" tooltip="Fill counts from data. Breaks must have been set-up before calling this method.">FillCounts</ref>(data);</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="185"><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal"></highlight><highlight class="comment">/*********<sp/>PUBLIC<sp/>METHODS<sp/>***********/</highlight></codeline>
<codeline lineno="193" refid="structhisto_1_1_histo_1a858c655679d179ba3697a70cdbbee206" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="structhisto_1_1_histo_1a858c655679d179ba3697a70cdbbee206" kindref="member" tooltip="Return the index of.">IndexFromValue</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T<sp/>&amp;value){</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>lo{0},hi{bins},<sp/>newb;<sp/></highlight><highlight class="comment">//<sp/>include<sp/>right<sp/>border<sp/>in<sp/>the<sp/>last<sp/>bin.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(value<sp/>&gt;=<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>[lo]<sp/>&amp;&amp;<sp/>(value<sp/>&lt;<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>[hi]<sp/>||<sp/>histo::isequalthan&lt;T&gt;(value,<ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>[hi])<sp/>)){</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(<sp/>hi<sp/>-<sp/>lo<sp/>&gt;=<sp/>2){</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newb<sp/>=<sp/>(hi-lo)/2;</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(value<sp/>&gt;=<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>[newb])<sp/>lo<sp/>=<sp/>newb;</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>hi<sp/>=<sp/>newb;</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/><ref refid="classhisto_1_1histo__error" kindref="compound">histo_error</ref>(</highlight><highlight class="stringliteral">&quot;<sp/>IndexFromValue:<sp/>&quot;</highlight><highlight class="normal">+<sp/>std::to_string(value)<sp/>+<sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/>is<sp/>out<sp/>of<sp/>bonds&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lo;</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="207"><highlight class="normal"></highlight></codeline>
<codeline lineno="209" refid="structhisto_1_1_histo_1a59b9327bd63469648ca27cd666adab79" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="structhisto_1_1_histo_1a59b9327bd63469648ca27cd666adab79" kindref="member" tooltip="Resize counts and reset value to zero.">ResetCounts</ref>(){</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>.resize(bins);</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>&amp;c<sp/>:<sp/><ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>){</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="223" refid="structhisto_1_1_histo_1a24f8c6d3b739d1199674198f49aebd28" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;PRECI_INTEGER&gt;&amp;<sp/><ref refid="structhisto_1_1_histo_1a24f8c6d3b739d1199674198f49aebd28" kindref="member" tooltip="Fill counts from data. Breaks must have been set-up before calling this method.">FillCounts</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;data){</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>&amp;v<sp/>:<sp/>data){</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[<ref refid="structhisto_1_1_histo_1a858c655679d179ba3697a70cdbbee206" kindref="member" tooltip="Return the index of.">IndexFromValue</ref>(v)]<sp/>++<sp/>;</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>;</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="229"><highlight class="normal"></highlight></codeline>
<codeline lineno="235" refid="group___counts_manipulation_1ga61ba4ed541dbfedfce4c20b7895e8303" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group___counts_manipulation_1ga61ba4ed541dbfedfce4c20b7895e8303" kindref="member" tooltip="Increase count by one, checking if exceeds max_integer_.">Increase</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>index){</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[index]<sp/>==<sp/>max_integer_)</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/><ref refid="classhisto_1_1histo__error" kindref="compound">histo_error</ref>(</highlight><highlight class="stringliteral">&quot;Increase<sp/>has<sp/>exceded<sp/>PRECI_INTEGER.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/>Index:<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>std::to_string(index)<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;<sp/>Value:<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>std::to_string(<ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[index])<sp/>);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[index]++;</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="241"><highlight class="normal"></highlight></codeline>
<codeline lineno="245" refid="group___counts_manipulation_1gadd9866333da884f97a91ff1bc28ee834" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group___counts_manipulation_1gadd9866333da884f97a91ff1bc28ee834" kindref="member" tooltip="Decrease count by one, checking if it goes negative.">Decrease</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>index){</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[index]<sp/>&lt;=<sp/>0<sp/>)</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/><ref refid="classhisto_1_1histo__error" kindref="compound">histo_error</ref>(</highlight><highlight class="stringliteral">&quot;Decrease<sp/>has<sp/>reached<sp/>negative<sp/>value.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/>Index:<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>std::to_string(index)<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;<sp/>Value:<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>std::to_string(<ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[index])<sp/>);</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[index]--;</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="251"><highlight class="normal"></highlight></codeline>
<codeline lineno="256" refid="group___counts_manipulation_1gaae55ca251a6c64f214ce6bd0a1772d44" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="group___counts_manipulation_1gaae55ca251a6c64f214ce6bd0a1772d44" kindref="member" tooltip="Set count value. Checks for negative or greater than max_integer_.">SetCount</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>index,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>&amp;<sp/>v<sp/>){</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(v<sp/>&lt;<sp/>0<sp/>||<sp/>v<sp/>&gt;<sp/>max_integer_)</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/><ref refid="classhisto_1_1histo__error" kindref="compound">histo_error</ref>(</highlight><highlight class="stringliteral">&quot;SetCount<sp/>to<sp/>a<sp/>negative<sp/>value,<sp/>or<sp/>greater<sp/>than<sp/>allowed&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/>Index:<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>std::to_string(index)<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;<sp/>Value:<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>std::to_string(<ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[index])<sp/>);</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1af5eab179e063fbe3769d0c9ab823fa0d" kindref="member">counts</ref>[index]<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">PRECI_INTEGER</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(v);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="262"><highlight class="normal"></highlight></codeline>
<codeline lineno="265"><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/>PRECI_INTEGER<sp/>max_integer_{std::numeric_limits&lt;PRECI_INTEGER&gt;::max()};</highlight></codeline>
<codeline lineno="268"><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CheckIfMonotonicallyIncreasing(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;input_breaks){</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>prev_value<sp/>=<sp/>input_breaks[0];</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>input_breaks.begin()<sp/>+<sp/>1,<sp/>it_end<sp/>=<sp/>input_breaks.end();</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=it_end;<sp/>it++)</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(*it<sp/>&lt;=<sp/>prev_value)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prev_value<sp/>=<sp/>*it;</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;T&gt;&amp;<sp/>CalculateBreaks(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;<sp/>data,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::pair&lt;T,T&gt;<sp/>&amp;<sp/>rang,<sp/><ref refid="group__breaks__methods_1ga132dcd8240c4bb268ed00b1e4fa3ebab" kindref="member" tooltip="Breaks method to optimal calculation of breaks based on input data and range. Scott...">histo::breaks_method</ref><sp/>method<sp/>){</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(method)<sp/>{</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__breaks__methods_1gga132dcd8240c4bb268ed00b1e4fa3ebabae05f2a05e4a163aac88bf64dc92cb36e" kindref="member">Scott</ref>:</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ScottMethod(data,rang);</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>histo_error(</highlight><highlight class="stringliteral">&quot;CalculateBreaks:<sp/>No<sp/>Valid<sp/>Method<sp/>selected<sp/>to<sp/>calculate<sp/>breaks.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="298"><highlight class="normal"></highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CheckBreaksAreEquidistant(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;<sp/>input_breaks){</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>diff<sp/>=<sp/>input_breaks[1]<sp/>-<sp/>input_breaks[0];</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>input_breaks.begin()<sp/>+<sp/>1,<sp/>it_end<sp/>=<sp/>input_breaks.end();</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it!=it_end;<sp/>it++)</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!isequalthan&lt;T&gt;(*it<sp/>-<sp/>*(it-1),<sp/>diff))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="308"><highlight class="normal"></highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>BalanceBreaksWithRange(std::vector&lt;T&gt;<sp/>&amp;input_breaks,<sp/>std::pair&lt;T,T&gt;<sp/>input_range){</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!CheckBreaksAreEquidistant(input_breaks))</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>histo_error(</highlight><highlight class="stringliteral">&quot;BalanceBreaksWithRange<sp/>cannot<sp/>be<sp/>applied<sp/>in<sp/>NON<sp/>Equidistant<sp/>breaks&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="312"><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nbins<sp/>=<sp/>input_breaks.size()<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>width<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>input_breaks[1]<sp/>-<sp/>input_breaks[0];</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>diff_low<sp/>is<sp/>&gt;<sp/>0<sp/>when<sp/>it<sp/>does<sp/>not<sp/>reach<sp/>range,<sp/>and<sp/>&lt;<sp/>0<sp/>when<sp/>it<sp/>goes<sp/>beyond.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>diff_low<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>input_breaks[0]<sp/>-<sp/>input_range.first;</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>diff_upper<sp/>is<sp/>&lt;<sp/>0<sp/>when<sp/>it<sp/>does<sp/>not<sp/>reach<sp/>range,<sp/>and<sp/>&gt;0<sp/>when<sp/>it<sp/>goes<sp/>beyond.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>diff_upper<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>input_breaks[nbins]<sp/>-<sp/>input_range.second;</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>diff_low_isZero<sp/><sp/><sp/>=<sp/>isequalthan&lt;T&gt;(diff_low,<sp/>0);</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>diff_upper_isZero<sp/>=<sp/>isequalthan&lt;T&gt;(diff_upper,<sp/>0);</highlight></codeline>
<codeline lineno="321"><highlight class="normal"></highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(diff_low_isZero<sp/>&amp;&amp;<sp/>diff_upper_isZero)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="323"><highlight class="normal"></highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Put<sp/>the<sp/>first<sp/>break<sp/>in<sp/>the<sp/>range.first,<sp/>and<sp/>move<sp/>all<sp/>breaks<sp/>accordingly.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!diff_low_isZero)<sp/>ShiftBreaks(input_breaks,<sp/>-diff_low);</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CheckAndUpdateDiff(diff_upper,<sp/>diff_upper_isZero,<sp/>input_breaks[nbins],<sp/>input_range.second);</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(diff_upper_isZero)<sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="328"><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>it<sp/>is<sp/>better<sp/>to<sp/>remove<sp/>the<sp/>last<sp/>break<sp/>than<sp/>to<sp/>add<sp/>more.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Biased<sp/>to<sp/>add<sp/>more<sp/>(1<sp/>is<sp/>no<sp/>bias).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>bias_to_add_bin<sp/>=<sp/>0.8;</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>diff_upper_before<sp/>=<sp/>input_breaks[nbins<sp/>-<sp/>1]<sp/>-<sp/>input_range.second;</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((diff_upper_before<sp/>&lt;<sp/>0)<sp/>&amp;&amp;<sp/>(diff_upper<sp/>&gt;<sp/>0<sp/>)</highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>(<sp/>fabs(diff_upper_before)<sp/>&lt;<sp/>bias_to_add_bin<sp/>*<sp/>fabs(diff_upper)<sp/>))</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nbins--;</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_breaks.pop_back();</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>width_to_expand<sp/>=<sp/>diff_upper_before/nbins;</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ShrinkOrExpandBreaks(input_breaks,<sp/>-width_to_expand);</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CheckAndUpdateDiff(diff_upper,<sp/>diff_upper_isZero,<sp/>input_breaks[nbins],<sp/>input_range.second);</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(diff_upper_isZero)<sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="343"><highlight class="normal"></highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>diff_upper<sp/>is<sp/>&lt;0,<sp/><sp/>add<sp/>bins<sp/>until<sp/>reach<sp/>the<sp/>upper<sp/>range.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(diff_upper<sp/>&lt;<sp/>0){</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nbins++;</highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_breaks.push_back(input_range.first<sp/>+<sp/>nbins<sp/>*<sp/>width);</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>diff_upper<sp/><sp/>=<sp/>input_breaks[nbins]<sp/>-<sp/>input_range.second;</highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>diff_upper_isZero<sp/>=<sp/>isequalthan&lt;T&gt;(diff_upper,<sp/>0);</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(diff_upper_isZero)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="352"><highlight class="normal"></highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>diff_upper<sp/>&gt;<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Shrink<sp/>the<sp/>width<sp/>of<sp/>the<sp/>breaks,<sp/>and<sp/>calculate<sp/>the<sp/>new<sp/>positions.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>width_to_shrink<sp/>=<sp/>diff_upper<sp/>/<sp/>nbins;</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ShrinkOrExpandBreaks(input_breaks,<sp/>-<sp/>width_to_shrink);</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="359"><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>CheckAndUpdateDiff(T<sp/>&amp;<sp/>diff,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>&amp;<sp/>diff_isZero,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T<sp/>&amp;<sp/>rhs,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T<sp/>&amp;<sp/>lhs){</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>diff<sp/>=<sp/>rhs<sp/>-<sp/>lhs;</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>diff_isZero<sp/>=<sp/>isequalthan&lt;T&gt;(diff,<sp/>0);</highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ShiftBreaks(std::vector&lt;T&gt;<sp/>&amp;input_breaks,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T<sp/>&amp;<sp/>d){</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>&amp;v<sp/>:<sp/>input_breaks){</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v<sp/>=<sp/>v<sp/>+<sp/>d;</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ShrinkOrExpandBreaks(std::vector&lt;T&gt;<sp/>&amp;input_breaks,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T<sp/>&amp;<sp/>d){</highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i{0}<sp/>;</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>&amp;v<sp/>:<sp/>input_breaks){</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v<sp/>=<sp/>v<sp/>+<sp/>i*d;</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i++;</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;T&gt;&amp;<sp/>ScottMethod(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;T&gt;<sp/>&amp;data,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::pair&lt;T,T&gt;<sp/>&amp;rang){</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PRECI<sp/>sigma<sp/>=<sp/>variance_welford&lt;PRECI,std::vector&lt;T&gt;&gt;(data);</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PRECI<sp/>width<sp/><sp/>=<sp/>3.5<sp/>*<sp/>sqrt(sigma)<sp/>/<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">PRECI</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(<sp/>data.size()<sp/>);</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bins<sp/><sp/><sp/><sp/>=<sp/>std::ceil(<sp/>(rang.second<sp/>-<sp/>rang.first)<sp/>/<sp/>width);</highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>.resize(bins<sp/>+<sp/>1<sp/>);</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i!=bins<sp/>+<sp/>1;<sp/>i++){</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>[i]<sp/>=<sp/><ref refid="structhisto_1_1_histo_1aae8bee662fbf5b3f00e2b5bc8e304036" kindref="member">range</ref>.first<sp/>+<sp/>i*width;</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Non<sp/>balanced<sp/>breaks&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::cout&lt;&lt;<sp/>&quot;bins<sp/>is:<sp/>&quot;<sp/>&lt;&lt;<sp/>bins<sp/>&lt;&lt;&quot;<sp/>width<sp/>is:<sp/>&quot;&lt;&lt;<sp/>width<sp/>&lt;&lt;<sp/>&quot;<sp/>sigma<sp/>is:<sp/>&quot;<sp/>&lt;&lt;<sp/>sigma<sp/><sp/>&lt;&lt;std::endl;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;first<sp/>break&quot;<sp/>&lt;&lt;<sp/>breaks[0]<sp/>&lt;&lt;<sp/>&quot;<sp/>Second<sp/>Break&quot;<sp/>&lt;&lt;<sp/>breaks[bins]<sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::for_each(std::begin(breaks),<sp/>std::end(breaks),<sp/>[](const<sp/>T&amp;<sp/>v)<sp/>{std::cout&lt;&lt;v<sp/>&lt;&lt;std::endl;});</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="397"><highlight class="normal"></highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BalanceBreaksWithRange(<ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>,<sp/><ref refid="structhisto_1_1_histo_1aae8bee662fbf5b3f00e2b5bc8e304036" kindref="member">range</ref>);</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bins<sp/>=<sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>.size()<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Balanced<sp/>new<sp/>breaks&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::cout&lt;&lt;<sp/>&quot;bins<sp/>is:<sp/>&quot;<sp/>&lt;&lt;<sp/>bins<sp/>&lt;&lt;&quot;<sp/>width<sp/>is:<sp/>&quot;&lt;&lt;<sp/>breaks[1]-breaks[0]<sp/><sp/>&lt;&lt;std::endl;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;first<sp/>break&quot;<sp/>&lt;&lt;<sp/>breaks[0]<sp/>&lt;&lt;<sp/>&quot;<sp/>Second<sp/>Break&quot;<sp/>&lt;&lt;<sp/>breaks[bins]<sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>std::for_each(std::begin(breaks),<sp/>std::end(breaks),<sp/>[](const<sp/>T&amp;<sp/>v)<sp/>{std::cout&lt;&lt;v<sp/>&lt;&lt;std::endl;});</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="structhisto_1_1_histo_1a742cff9dfd900b400959621fa72eb0bb" kindref="member">breaks</ref>;</highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="406"><highlight class="normal">};</highlight></codeline>
<codeline lineno="407"><highlight class="normal"></highlight></codeline>
<codeline lineno="408"><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>namespace<sp/>histo</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
    </programlisting>
    <location file="/home/phc/repository_local/histo-header/src/histo-header.h"/>
  </compounddef>
</doxygen>
